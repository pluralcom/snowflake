export default [
  {
    summary: "Solid Software Engineering Foundations",
    signals: `
- Able to explain and use Arrays, LinkedLists, Dictionaries etc in practical programming tasks
- Basic sorting, searching and data structure traversal and retrieval algorithms
- Basic understanding of compilers, linker and interpreters. Understands what assembly code is and how things work at the hardware level. Some knowledge of virtual memory and paging.
- Uses version control and understands the basic tools of Git
- Knows how to use the command line and run basic commands
- Understands and writes automated unit tests and comes up with good unit test cases for the code that is being written
- Writes testable code
- Understands SOLID principles
- Able to break up problem into multiple functions
- Able to break up problem space and design solution as long as it is within the same platform/technology
- Functions, files and folders are grouped logically
- Checks all arguments and asserts critical assumptions in code
- Basic error handling around code that can throw exceptions/generate errors
- Knows their way around the interface, able to effectively use the IDE using menus.
- Has heard about and used one popular frameworks available for the platform.
- Has adapt grasp of their preferred programing language syntax and runtime operation model.
- Knows Imperative or Object Oriented and declarative (SQL), bonus if you understand static vs dynamic typing, weak vs strong typing and static inferred types.
- Knows basic database concepts, normalization, ACID, transactions and can write simple selects
- Understands the basics of databases and data design
- Knows about data structures and when to use them
- Aware of [Clean Code](https://github.com/ryanmcdermott/clean-code-javascript)

- Basic knowledge of the code layout and how to build the system
- Aware of popular books and blogs, bonus if an avid consumer
- Peers can understand what is being said. Good spelling and grammar.
    `,
  },
  {
    summary: "Proficient Software Engineering Foundations",
    signals: `
- Deeply understands design patterns and can implement them correctly
- Knows different programming paradigms (Object Oriented, Functional Programing) and can implement them correctly
- Experience with Functional Paradigm, added bonus if they understand lazy evaluation, currying, continuations
- Knows when to use immutable objects correctly
- Deep knowledge of their preferred programing language syntax and runtime operation model.
- Knows space and time tradeoffs of the basic data structures, Arrays vs LinkedLists, Able to explain how hashtables can be implemented and can handle collisions, Priority queues and ways to implement them etc.
- Has grasp of Tree, Graph, simple greedy and divide and conquer algorithms, is able to understand the relevance of the levels of this matrix.
- Proficient at using version control and understands the basic tools of Git
- Has written code in TDD manner
- Can setup a script to build the basic system
- Able to come up with reusable functions/objects that solve the overall problem
- Each physical file has a unique purpose, for e.g. one class definition, one feature implementation etc.
- No long functions, comments explaining unusual code, bug fixes, code assumptions
- Makes sure to check return values and check for exceptions around code that can fail.
- Ensures that error/exceptions leave program in good state, resources, connections and memory is all cleaned up properly
- Knows of ecosystem
- Has used more than one framework in a professional capacity and is well-versed with the idioms of the frameworks.
- Able to transfer knowledge to other platform and programing languages becoming proficient faster

- Knows about container base infrastructure
- Knows about the Kubernetes distributed computation platform
- Knows about database scalability patterns
- Can use recursion effectively to optimize algorithm performance
- Able to use the [C4 diagram model](https://c4model.com/) to sketch architecture
- Can bootstrap a proper scalable project file structure
- Spots performance or security issues during Code Reviews

- A consumer of popular books (Design Patterns, Peopleware, Programming Pearls, Algorithm Design Manual, Pragmatic Programmer, Mythical Man month) and blogs
- Maintains a link blog with some collection of useful articles and tools that he/she has collected
    `,
  },
  {
    summary: "Advanced Software Engineering Knowledge",
    signals: `
- Able to design systems that span multiple technologies/platforms.
- Code organization at a physical level closely matches design and looking at file names and folder distribution provides insights into design
- Language exposure extends to Concurrent (Erlang, Oz) and Logic (Prolog)
- Has deep knowledge and expertise of more then one platform and programing language.
- Code assumptions are verified using asserts, code flows naturally â€“ no deep nesting of conditionals or methods
- Physical layout of source tree matches logical hierarchy and organization. The directory names and organization provide insights into the design of the system.

- Creates own libraries and publish them on package registry
- Able to suggest better alternatives and flows to given requirements based on experience

- Acts as primary maintainer for existing critical systems
- Designs moderately complex systems
- Able to visualize and design complex systems with multiple product lines and integrations with external systems. Also should be able to design operations support systems like monitoring, reporting, fail overs etc.
- Makes major version upgrades to libraries
- Able to understand and communicate thoughts/design/ideas/specs in a unambiguous manner and adjusts communication as per the context
- Designs architectures on the system level
- Knowledge of advanced data structures like B-trees, binomial and fibonacci heaps, AVL/Red Black trees, Splay Trees, Skip Lists, tries etc.
- Able to recognize and code dynamic programming solutions, good knowledge of graph algorithms, good knowledge of numerical computation algorithms, able to identify NP problems etc.
- Able to visualize and design complex systems with multiple product lines and integrations with external systems. Also should be able to design operations support systems like monitoring, reporting, fail overs etc.
- Spots performance or security issues in architecture
- Able to understand and communicate thoughts/design/ideas/specs in a unambiguous manner and adjusts communication as per the context
- Maintains a blog in which personal insights and thoughts on programming are shared
    `,
  },
  // {
  //   summary: "Master Software Engineering Knowledge",
  //   signals: `
  // 	- Compiles their own Linux kernel
  // 	- Wrote a book on a subject
  // `,
  // },
];
